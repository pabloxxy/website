<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="styles.css">
  <title>Pablo de la Fuente - Spectra</title>
  <link rel="shortcut icon" href="images/favicon/favicon.ico">
  <script>
    fetch('favicon.html')
      .then(response => response.text())
      .then(data => {
        document.head.insertAdjacentHTML('afterbegin', data);
      });
  </script>

  <!-- mathjax.org - La cosa que compila notación matemática -->
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
</head>

<body class="home-page" style="overflow: hidden;">

  <!-- Back button -->
  <a href="home" class="gif-back-button">
    <img src="images/gifs/back1.gif" alt="Back to Home">
  </a>

  <!-- Sidebar -->
<div class="sidebar">
  <a class="sidebar-button active" data-section="gallery">Gallery</a>
  <a class="sidebar-button" data-section="about">About</a>
  <a class="sidebar-button" data-section="code">Code</a>
  <a class="sidebar-button" data-section="semicircle">Semicircle Law</a>
</div>


<div id="content-sections">

  <!-- Gallery Section (default visible) -->
  <section id="gallery" class="content-section">
   <div class="gallery-container">

    <!-- Image 1 -->
    <div class="image-wrapper active" style="z-index: 5; top: 10%; left: 0%;">
      <img src="images/spectra/matrix1.webp" alt="?">
    </div>
    <!-- Image 2 -->
    <div class="image-wrapper" style="z-index: 4; top: 0%; left: 20%;">
      <img src="images/spectra/matrix2.webp" alt="?">
    </div>  
    <!-- Image 3 -->
    <div class="image-wrapper" style="z-index: 3; bottom: 15%; right: 0%;">
      <img src="images/spectra/matrix3.webp" alt="?">
    </div>
    <!-- Image 4 -->
    <div class="image-wrapper" style="z-index: 2; bottom: 0%; right: 10%;">
      <img src="images/spectra/matrix4.webp" alt="?">
    </div> 
    <!-- Image 5 -->
    <div class="image-wrapper" style="z-index: 1; bottom: 5%; left: 10%;">
      <img src="images/spectra/matrix5.webp" alt="?">
    </div>

   </div>

   <div id="spectra-header">Visualizing the spectra of random matrices</div>
  </section>


  <!-- About Section (initially hidden) -->
  <section id="about" class="content-section" style="display:none;">
    <div class="spectra-text aboutspectra-content">
      <h2>About Spectra</h2>
      <p>
      Let's consider a matrix \(M\) of size \(n\times n\) whose eigenvalues are \( \{\lambda_1, \lambda_2, \cdots, \lambda_n \}.\)
      We define its empirical spectral distribution as the probability measure
      \[ \mu = \frac{1}{n} \sum_{i=1}^n \delta_{\lambda_i}.\] 
      Notice that if \( M\) is a random matrix, i.e. a matrix whose entries are real random variables, then \( \mu \) is a random probability measure.
      We can then naturally define the expectation of \( \mu \), a deterministic probability measure, by the way it interacts with bounded continuous functions. 
      Since \( \mu\) is a random measure then for each bounded continuous function \(f:\mathbb{R}\rightarrow \mathbb{R}\), the integral 
      \[\int f \, d\mu\] 
      is a real random variable.
      We then define the expectation of \( \mu\), denoted as \( \mathbb{E}(\mu )\), as the deterministic measure such that for every continuous bounded function \(f:\mathbb{R}\rightarrow \mathbb{R}\)
      \[ \int f \, d\mathbb{E}(\mu ) = \mathbb{E}\left(\int f \, d\mu\right) .\]
      The existence and uniqueness of the the measure defined this way can be rigorously justified by the <a href="https://en.wikipedia.org/wiki/Riesz%E2%80%93Markov%E2%80%93Kakutani_representation_theorem"> Riez-Markov-Kakutani representation theorem</a>.
      </p>
    </div>
  </section>
  
  <!-- Code Section (initially hidden) -->
  <section id="code" class="content-section" style="display:none;">
    <div class="code-content">
      <h2>Code Implementation</h2>
      <p>Code content here...</p>
    </div>
  </section>
 

  <!-- Semicircle Section (initially hidden) -->
  <section id="semicircle" class="content-section" style="display:none;">
   <div class="semicircle-container">

    <!-- Left Column: Explanation -->
    <div class="spectra-text aboutspectra-content">
      <h2>Semicircle Law</h2>
      <p>Wigner's semicircle law describes the eigenvalue distribution of large symmetric random matrices. Let's consider symmetric 
         matrices of size \(n\times n\) whose entries are independent (modulo the symmetry), centered and have variance \( 1\). Let's denote
         their necessarily real eigenvalues as 
         \[ \lambda_1\leq \lambda_2 \leq \cdots \leq \lambda_n. \]
         Wigner proved that the sequence of their Empirical Spectral Distributions, i.e. the sequence of random measures given by
         \[ \frac{1}{n} \sum_{i=1}^n \delta_{\lambda_i},\] 
         almost surely converges weakly to a deterministic measure: the semicircle law, whose probability density function is given by 
         \[ f(x) =
                  \begin{cases}
                  \frac{1}{2\pi} \sqrt{4-x^2} & \text{if } |x|\leq 2, \\
                  0 & \text{if } |x|>2
                  \end{cases}
        \]
        a semicircle centered at \( 0\) of radius \(2 \) and normalized so it is a probability density function.
      </p>

      <p>
        Víctor Pérez Abreu me mandó un mensaje muy lindo cuando leyó mi tesis. Lo quiero guardar aquí. El 14 de septiembre de 2025 a las 21:51 me envió: 
        Buenas noches, Pablo. Hoy pasé una muy buena y placentera tarde leyendo tu tesis. 
        Es una tesis de una calidad extraordinaria en cuanto a estructura, hilo conductor, presentación, 
        rigor, demuestras una compresión profunda de los temas que tratas de la teoría de matrices aleatorias 
        y sus conexiones con combinatoria, probabilidad y concentración. El prefacio y la introducción de cada 
        capítulo invitan a seguir leyendo la tesis. Los preliminares y el apéndice están muy bien seleccionados 
        y expuestos. Las referencias están muy bien escogidas y son las relevantes para el tema de ley del semicirculo 
        y concentración de la norma. Los agradecimientos muestran tu sensibilidad, entusiasmo y humildad. 
        Me emocionó muy sensiblemente lo que mencionas de mi. En términos beisboleros llegas a la novena entrada 
        el día 26 de septiembre tirando juego perfecto, haré todo lo posible por ser espectador de las últimas tres entradas [sic]. 
        Te felicito!!!
      </p>
    </div>
    
    <!-- Right Column: PDF -->
    <div class="semicircle-pdf aboutspectra-content">
      <div id="my-pdf"></div>
    </div>
   </div>
  
   <script src="https://unpkg.com/pdfobject"></script>
   <script>PDFObject.embed("tesis.pdf", "#my-pdf");</script>
  </section>
</div>


<!-- Script for side menu -->
<script>
// Sidebar navigation functionality
document.querySelectorAll('.sidebar-button').forEach(button => {
  button.addEventListener('click', function(e) {
    e.preventDefault();
    
    // Get target section from data attribute
    const targetSection = this.dataset.section;
    
    // Hide all sections
    document.querySelectorAll('.content-section').forEach(section => {
      section.style.display = 'none';
    });
    
    // Show target section
    document.getElementById(targetSection).style.display = 'block';
    
    // Update active button
    document.querySelectorAll('.sidebar-button').forEach(btn => {
      btn.classList.remove('active');
    });
    this.classList.add('active');
  });
});
</script>



<script>
document.addEventListener('DOMContentLoaded', function() {
    const wrappers = document.querySelectorAll('.image-wrapper');
    const galleryContainer = document.querySelector('.gallery-container');
    let topZIndex = 5;
    let isDragging = false;
    let currentWrapper = null;
    let startX, startY, initialX, initialY, usesBottom, usesRight;
    
    // Initialize z-index values and convert all positions to left/top
    wrappers.forEach((wrapper, i) => {
        wrapper.style.zIndex = 5 - i;
        wrapper.style.cursor = 'grab';
        
        // Convert any bottom/right positioning to left/top
        convertPositionToLeftTop(wrapper);
    });
    
    // Function to convert bottom/right positioning to left/top
    function convertPositionToLeftTop(wrapper) {
        const style = window.getComputedStyle(wrapper);
        const galleryRect = galleryContainer.getBoundingClientRect();
        const wrapperRect = wrapper.getBoundingClientRect();
        
        // Convert bottom to top
        if (style.bottom !== 'auto') {
            const bottomValue = parseFloat(style.bottom);
            wrapper.style.top = `${((galleryRect.height - wrapperRect.height - bottomValue) / galleryRect.height) * 100}%`;
            wrapper.style.bottom = 'auto';
        }
        
        // Convert right to left
        if (style.right !== 'auto') {
            const rightValue = parseFloat(style.right);
            wrapper.style.left = `${((galleryRect.width - wrapperRect.width - rightValue) / galleryRect.width) * 100}%`;
            wrapper.style.right = 'auto';
        }
        
        // Store initial positions
        wrapper.dataset.initialLeft = wrapper.style.left;
        wrapper.dataset.initialTop = wrapper.style.top;
    }
    
    // Mouse down event - start dragging
    wrappers.forEach(wrapper => {
        wrapper.addEventListener('mousedown', function(e) {
            isDragging = true;
            currentWrapper = this;
            
            // Get initial positions
            const galleryRect = galleryContainer.getBoundingClientRect();
            const wrapperRect = this.getBoundingClientRect();
            
            // Calculate relative positions within gallery container
            startX = e.clientX;
            startY = e.clientY;
            
            // Store initial percentage positions
            initialX = (wrapperRect.left - galleryRect.left) / galleryRect.width * 100;
            initialY = (wrapperRect.top - galleryRect.top) / galleryRect.height * 100;
            
            // Change cursor to grabbing
            this.style.cursor = 'grabbing';
            this.classList.add('dragging');
            
            // Bring to front
            wrappers.forEach(w => w.classList.remove('active'));
            this.classList.add('active');
            
            // Update z-index
            topZIndex++;
            this.style.zIndex = topZIndex;
            
            e.preventDefault();
        });
    });
    
    // Mouse move event - handle dragging
    document.addEventListener('mousemove', function(e) {
        if (!isDragging || !currentWrapper) return;
        
        const galleryRect = galleryContainer.getBoundingClientRect();
        
        // Calculate movement delta in percentages
        const deltaX = ((e.clientX - startX) / galleryRect.width) * 100;
        const deltaY = ((e.clientY - startY) / galleryRect.height) * 100;
        
        // Apply new position
        currentWrapper.style.left = `${initialX + deltaX}%`;
        currentWrapper.style.top = `${initialY + deltaY}%`;
    });
    
    // Mouse up event - stop dragging
    document.addEventListener('mouseup', function() {
        if (isDragging && currentWrapper) {
            currentWrapper.style.cursor = 'grab';
            currentWrapper.classList.remove('dragging');
        }
        isDragging = false;
        currentWrapper = null;
    });
    
    // Touch events for mobile support
    wrappers.forEach(wrapper => {
        wrapper.addEventListener('touchstart', function(e) {
            if (e.touches.length !== 1) return;
            
            isDragging = true;
            currentWrapper = this;
            
            const touch = e.touches[0];
            const galleryRect = galleryContainer.getBoundingClientRect();
            const wrapperRect = this.getBoundingClientRect();
            
            startX = touch.clientX;
            startY = touch.clientY;
            
            initialX = (wrapperRect.left - galleryRect.left) / galleryRect.width * 100;
            initialY = (wrapperRect.top - galleryRect.top) / galleryRect.height * 100;
            
            wrappers.forEach(w => w.classList.remove('active'));
            this.classList.add('active');
            
            topZIndex++;
            this.style.zIndex = topZIndex;
            
            e.preventDefault();
        });
    });
    
    document.addEventListener('touchmove', function(e) {
        if (!isDragging || !currentWrapper || e.touches.length !== 1) return;
        
        const touch = e.touches[0];
        const galleryRect = galleryContainer.getBoundingClientRect();
        
        const deltaX = ((touch.clientX - startX) / galleryRect.width) * 100;
        const deltaY = ((touch.clientY - startY) / galleryRect.height) * 100;
        
        currentWrapper.style.left = `${initialX + deltaX}%`;
        currentWrapper.style.top = `${initialY + deltaY}%`;
        
        e.preventDefault();
    });
    
    document.addEventListener('touchend', function() {
        isDragging = false;
        currentWrapper = null;
    });
    
    // Handle window resize
    window.addEventListener('resize', function() {
        // Reconvert positions if needed after resize
        wrappers.forEach(wrapper => {
            if (!wrapper.dataset.initialLeft || !wrapper.dataset.initialTop) {
                convertPositionToLeftTop(wrapper);
            }
        });
    });
});
</script>

</body>
</html>